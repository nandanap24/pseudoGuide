const prisma = require("../config/db");

const questions = [
  // EASY QUESTIONS (10)
  {
    difficulty: "easy",
    title: "Two sum",
    description:
      "Two Sum ‚Äî Return indices of two numbers that add up to target.",
    answers: [
      [
        "BEGIN",
        "INPUT numbers, target",
        "FOR i ‚Üê 0 TO length(numbers) - 1 DO",
        "FOR j ‚Üê i + 1 TO length(numbers) - 1 DO",
        "IF numbers[i] + numbers[j] = target THEN",
        "OUTPUT i, j",
        "END",
        "END IF",
        "END FOR",
        "END FOR",
        "END",
      ],
      [
        "BEGIN",
        "INPUT numbers, target",
        "FOR i ‚Üê 0 TO length(numbers) - 2 DO",
        "SET j ‚Üê i + 1",
        "WHILE j < length(numbers) DO",
        "IF numbers[i] + numbers[j] = target THEN",
        "OUTPUT i, j",
        "END",
        "END IF",
        "SET j ‚Üê j + 1",
        "END WHILE",
        "END FOR",
        "END",
      ],
      [
        "BEGIN",
        "INPUT numbers, target",
        "SET found ‚Üê FALSE",
        "FOR i ‚Üê 0 TO length(numbers) - 1 DO",
        "FOR j ‚Üê i + 1 TO length(numbers) - 1 DO",
        "IF numbers[i] + numbers[j] = target THEN",
        "OUTPUT i, j",
        "SET found ‚Üê TRUE",
        "END",
        "END IF",
        "END FOR",
        "IF found = TRUE THEN",
        "END",
        "END IF",
        "END FOR",
        "END",
      ],
      [
        "BEGIN",
        "INPUT numbers, target",
        "SET i ‚Üê 0",
        "WHILE i < length(numbers) DO",
        "SET j ‚Üê i + 1",
        "WHILE j < length(numbers) DO",
        "IF numbers[i] + numbers[j] = target THEN",
        "OUTPUT i, j",
        "END",
        "END IF",
        "SET j ‚Üê j + 1",
        "END WHILE",
        "SET i ‚Üê i + 1",
        "END WHILE",
        "END",
      ],
      [
        "BEGIN",
        "INPUT numbers, target",
        "FOR i ‚Üê 0 TO length(numbers) - 1 DO",
        "FOR j ‚Üê 0 TO length(numbers) - 1 DO",
        "IF i ‚â† j AND numbers[i] + numbers[j] = target THEN",
        "OUTPUT i, j",
        "END",
        "END IF",
        "END FOR",
        "END FOR",
        "END",
      ],
      [
        "BEGIN",
        "INPUT numbers, target",
        "SET map ‚Üê empty",
        "FOR i ‚Üê 0 TO length(numbers) - 1 DO",
        "SET diff ‚Üê target - numbers[i]",
        "IF diff exists in map THEN",
        "OUTPUT map[diff], i",
        "END",
        "END IF",
        "SET map[numbers[i]] ‚Üê i",
        "END FOR",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Valid Parentheses",
    description: "Valid Parentheses ‚Äî Check if a string of brackets is valid.",
    answers: [
      [
        "BEGIN",
        "INPUT s",
        "REPEAT",
        "SET previous ‚Üê s",
        'REPLACE "()" in s with ""',
        'REPLACE "{}" in s with ""',
        'REPLACE "[]" in s with ""',
        "UNTIL s = previous",
        "IF s = empty string THEN",
        "OUTPUT true",
        "ELSE",
        "OUTPUT false",
        "END IF",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "SET stack ‚Üê empty",
        "FOR each character c in s DO",
        "IF c is '(' OR '{' OR '[' THEN",
        "PUSH c into stack",
        "ELSE",
        "IF stack is empty THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "SET top ‚Üê POP from stack",
        "IF c does not match top THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "END IF",
        "END FOR",
        "IF stack is empty THEN",
        "OUTPUT true",
        "ELSE",
        "OUTPUT false",
        "END IF",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "SET stack ‚Üê empty",
        "FOR i ‚Üê 0 TO length(s) - 1 DO",
        "IF s[i] is opening bracket THEN",
        "PUSH s[i] into stack",
        "ELSE",
        "IF stack is empty THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "open ‚Üê POP from stack",
        "IF open and s[i] are not matching THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "END IF",
        "END FOR",
        "IF stack is empty THEN",
        "OUTPUT true",
        "ELSE",
        "OUTPUT false",
        "END IF",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "SET stack ‚Üê empty",
        "SETi ‚Üê 0",
        "WHILE i < length(s) DO",
        "IF s[i] is opening bracket THEN",
        "PUSH s[i] into stack",
        "ELSE",
        "IF stack is empty THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "top ‚Üê POP from stack",
        "IF top does not match s[i] THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "END IF",
        "SET i ‚Üê i + 1",
        "END WHILE",
        "IF stack is empty THEN",
        "OUTPUT true",
        "ELSE",
        "OUTPUT false",
        "END IF",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "SET stack ‚Üê empty",
        "FOR each character c in s DO",
        "IF c is '(' THEN PUSH '(' into stack",
        "ELSE IF c is '{' THEN PUSH '{' into stack",
        "ELSE IF c is '[' THEN PUSH '[' into stack",
        "ELSE",
        "IF stack is empty THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "open ‚Üê POP from stack",
        "IF (open = '(' AND c ‚â† ')') OR",
        "(open = '{' AND c ‚â† '}') OR",
        "(open = '[' AND c ‚â† ']') THEN",
        "OUTPUT false",
        "END",
        "END IF",
        "END IF",
        "END FOR",
        "IF stack is empty THEN",
        "OUTPUT true",
        "ELSE",
        "OUTPUT false",
        "END IF",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Merge Two Sorted Lists",
    description: "Merge Two Sorted Lists ‚Äî Merge two sorted linked lists.",
    answers: [
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE empty merged_list",
        "WHILE list1 is not empty AND list2 is not empty DO",
        "IF list1.value < list2.value THEN",
        "ADD list1.value to merged_list",
        "MOVE list1 to next node",
        "ELSE",
        "ADD list2.value to merged_list",
        "MOVE list2 to next node",
        "END IF",
        "END WHILE",
        "WHILE list1 is not empty DO",
        "ADD list1.value to merged_list",
        "MOVE list1 to next node",
        "END WHILE",
        "WHILE list2 is not empty DO",
        "ADD list2.value to merged_list",
        "MOVE list2 to next node",
        "END WHILE",
        "OUTPUT merged_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE empty merged_list",
        "WHILE list1 is not empty OR list2 is not empty DO",
        "IF list2 is empty OR (list1 is not empty AND list1.value ‚â§ list2.value) THEN",
        "ADD list1.value to merged_list",
        "MOVE list1 to next node",
        "ELSE",
        "ADD list2.value to merged_list",
        "MOVE list2 to next node",
        "END IF",
        "END WHILE",
        "OUTPUT merged_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE empty merged_list",
        "SET p1 ‚Üê list1",
        "SET p2 ‚Üê list2",
        "WHILE p1 is not empty AND p2 is not empty DO",
        "IF p1.value < p2.value THEN",
        "ADD p1.value to merged_list",
        "MOVE p1 to next node",
        "ELSE",
        "ADD p2.value to merged_list",
        "MOVE p2 to next node",
        "END IF",
        "END WHILE",
        "ADD remaining nodes to merged_list",
        "OUTPUT merged_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "IF list1 is empty THEN",
        "OUTPUT list2",
        "END",
        "END IF",
        "IF list2 is empty THEN",
        "OUTPUT list1",
        "END",
        "END IF",
        "CREATE empty merged_list",
        "WHILE list1 is not empty AND list2 is not empty DO",
        "IF list1.value ‚â§ list2.value THEN",
        "ADD list1.value to merged_list",
        "MOVE list1 to next node",
        "ELSE",
        "ADD list2.value to merged_list",
        "MOVE list2 to next node",
        "END IF",
        "END WHILE",
        "ADD remaining nodes to merged_list",
        "OUTPUT merged_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE dummy_node",
        "SET current ‚Üê dummy_node",
        "WHILE list1 is not empty AND list2 is not empty DO",
        "IF list1.value < list2.value THEN",
        "SET current.next ‚Üê list1",
        "MOVE list1 to next node",
        "ELSE",
        "SET current.next ‚Üê list2",
        "MOVE list2 to next node",
        "END IF",
        "MOVE current to next node",
        "END WHILE",
        "IF list1 is not empty THEN",
        "SET current.next ‚Üê list1",
        "ELSE",
        "SET current.next ‚Üê list2",
        "END IF",
        "OUTPUT dummy_node.next",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Maximum Subarray",
    description:
      "Maximum Subarray ‚Äî Find contiguous subarray with maximum sum.",
    answers: [
      [
        "BEGIN",
        "INPUT array",
        "SET current_sum ‚Üê 0",
        "SET max_sum ‚Üê array[0]",
        "FOR each number in array DO",
        "SET current_sum ‚Üê current_sum + number",
        "IF current_sum > max_sum THEN",
        "SET max_sum ‚Üê current_sum",
        "END IF",
        "IF current_sum < 0 THEN",
        "SET current_sum ‚Üê 0",
        "END IF",
        "END FOR",
        "OUTPUT max_sum",
        "END",
      ],
      [
        "BEGIN",
        "INPUT array",
        "SET current_sum ‚Üê array[0]",
        "SET max_sum ‚Üê array[0]",
        "FOR i ‚Üê 1 TO length(array) - 1 DO",
        "SET current_sum ‚Üê MAX(array[i], current_sum + array[i])",
        "SET max_sum ‚Üê MAX(max_sum, current_sum)",
        "END FOR",
        "OUTPUT max_sum",
        "END",
      ],
      [
        "BEGIN",
        "INPUT array",
        "SET max_sum ‚Üê -‚àû",
        "SET current_sum ‚Üê 0",
        "FOR each element in array DO",
        "SET current_sum ‚Üê current_sum + element",
        "IF current_sum > max_sum THEN",
        "SET max_sum ‚Üê current_sum",
        "END IF",
        "IF current_sum < 0 THEN",
        "SET current_sum ‚Üê 0",
        "END IF",
        "END FOR",
        "OUTPUT max_sum",
        "END",
      ],
      [
        "BEGIN",
        "INPUT array",
        "SET max_sum ‚Üê array[0]",
        "FOR i ‚Üê 0 TO length(array) - 1 DO",
        "SET sum ‚Üê 0",
        "FOR j ‚Üê i TO length(array) - 1 DO",
        "SET sum ‚Üê sum + array[j]",
        "IF sum > max_sum THEN",
        "SET max_sum ‚Üê sum",
        "END IF",
        "END FOR",
        "END FOR",
        "OUTPUT max_sum",
        "END",
      ],
      [
        "BEGIN",
        "INPUT array",
        "SET current_sum ‚Üê 0",
        "SET max_sum ‚Üê array[0]",
        "i ‚Üê 0",
        "WHILE i < length(array) DO",
        "SET current_sum ‚Üê current_sum + array[i]",
        "IF current_sum > max_sum THEN",
        "SET max_sum ‚Üê current_sum",
        "END IF",
        "IF current_sum < 0 THEN",
        "SET current_sum ‚Üê 0",
        "END IF",
        "SET i ‚Üê i + 1",
        "END WHILE",
        "OUTPUT max_sum",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Best Time to Buy and Sell Stock",
    description:
      "Best Time to Buy and Sell Stock ‚Äî Max profit by buying low & selling high.",
    answers: [
      [
        "BEGIN",
        "INPUT prices",
        "SET min_price ‚Üê prices[0]",
        "SET max_profit ‚Üê 0",
        "FOR each price in prices DO",
        "IF price < min_price THEN",
        "SET min_price ‚Üê price",
        "END IF",
        "SET profit ‚Üê price - min_price",
        "IF profit > max_profit THEN",
        "SET max_profit ‚Üê profit",
        "END IF",
        "END FOR",
        "OUTPUT max_profit",
        "END",
      ],
      [
        "BEGIN",
        "INPUT prices",
        "SET min_price ‚Üê prices[0]",
        "SET max_profit ‚Üê 0",
        "FOR i ‚Üê 1 TO length(prices) - 1 DO",
        "IF prices[i] < min_price THEN",
        "SET min_price ‚Üê prices[i]",
        "ELSE IF prices[i] - min_price > max_profit THEN",
        "SET max_profit ‚Üê prices[i] - min_price",
        "END IF",
        "END FOR",
        "OUTPUT max_profit",
        "END",
      ],
      [
        "BEGIN",
        "INPUT prices",
        "SET min_price ‚Üê ‚àû",
        "SET max_profit ‚Üê 0",
        "FOR each value in prices DO",
        "IF value < min_price THEN",
        "SET min_price ‚Üê value",
        "END IF",
        "SET profit ‚Üê value - min_price",
        "IF profit > max_profit THEN",
        "SET max_profit ‚Üê profit",
        "END IF",
        "END FOR",
        "OUTPUT max_profit",
        "END",
      ],
      [
        "BEGIN",
        "INPUT prices",
        "SET min_price ‚Üê prices[0]",
        "SET max_profit ‚Üê 0",
        "SET i ‚Üê 1",
        "WHILE i < length(prices) DO",
        "IF prices[i] < min_price THEN",
        "SET min_price ‚Üê prices[i]",
        "ELSE",
        "SET profit ‚Üê prices[i] - min_price",
        "IF profit > max_profit THEN",
        "SET max_profit ‚Üê profit",
        "END IF",
        "END IF",
        "SET i ‚Üê i + 1",
        "END WHILE",
        "OUTPUT max_profit",
        "END",
      ],
      [
        "BEGIN",
        "INPUT prices",
        "SET max_profit ‚Üê 0",
        "FOR i ‚Üê 0 TO length(prices) - 2 DO",
        "FOR j ‚Üê i + 1 TO length(prices) - 1 DO",
        "SET profit ‚Üê prices[j] - prices[i]",
        "IF profit > max_profit THEN",
        "SET max_profit ‚Üê profit",
        "END IF",
        "END FOR",
        "END FOR",
        "OUTPUT max_profit",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Find minimum of two numbers",
    description: "Write pseudocode to find the minimum of two numbers",
    answers: [
      [
        "START",
        "READ a, b",
        "IF a < b THEN",
        "PRINT a",
        "ELSE",
        "PRINT b",
        "END",
      ],
      [
        "START",
        "INPUT a, b",
        "SET min = a",
        "IF b < min THEN",
        "SET min = b",
        "OUTPUT min",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Calculate simple interest",
    description: "Write pseudocode to calculate simple interest",
    answers: [
      [
        "START",
        "READ principal, rate, time",
        "SET interest = principal * rate * time / 100",
        "PRINT interest",
        "END",
      ],
      [
        "START",
        "INPUT p, r, t",
        "SET si = (p * r * t) / 100",
        "OUTPUT si",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Swap two numbers",
    description:
      "Write pseudocode to swap two numbers using a temporary variable",
    answers: [
      [
        "START",
        "READ a, b",
        "SET temp = a",
        "SET a = b",
        "SET b = temp",
        "PRINT a, b",
        "END",
      ],
      [
        "START",
        "INPUT x, y",
        "SET t = x",
        "SET x = y",
        "SET y = t",
        "OUTPUT x, y",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Calculate average of three numbers",
    description: "Write pseudocode to calculate the average of three numbers",
    answers: [
      [
        "START",
        "READ a, b, c",
        "SET sum = a + b + c",
        "SET average = sum / 3",
        "PRINT average",
        "END",
      ],
      [
        "START",
        "INPUT x, y, z",
        "SET avg = (x + y + z) / 3",
        "OUTPUT avg",
        "END",
      ],
    ],
  },
  {
    difficulty: "easy",
    title: "Convert Celsius to Fahrenheit",
    description:
      "Write pseudocode to convert temperature from Celsius to Fahrenheit",
    answers: [
      [
        "START",
        "READ celsius",
        "SET fahrenheit = (celsius * 9/5) + 32",
        "PRINT fahrenheit",
        "END",
      ],
      ["START", "INPUT c", "SET f = c * 1.8 + 32", "OUTPUT f", "END"],
    ],
  },

  // MEDIUM QUESTIONS (10)
  {
    difficulty: "medium",
    title: "Longest Substring Without Repeating Characters",
    description:
      "Longest Substring Without Repeating Characters ‚Äî length of the longest substring with all unique characters.",
    answers: [
      [
        "BEGIN",
        "INPUT s",
        "max_length ‚Üê 0",
        "FOR i ‚Üê 0 TO length(s) - 1 DO",
        "CREATE empty set seen_chars",
        "FOR j ‚Üê i TO length(s) - 1 DO",
        "IF s[j] IN seen_chars THEN",
        "BREAK",
        "END IF",
        "ADD s[j] TO seen_chars",
        "max_length ‚Üê MAX(max_length, j - i + 1)",
        "END FOR",
        "END FOR",
        "OUTPUT max_length",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "start ‚Üê 0",
        "max_length ‚Üê 0",
        "CREATE array visited initialized to FALSE",
        "FOR end ‚Üê 0 TO length(s) - 1 DO",
        "WHILE visited[s[end]] = TRUE DO",
        "visited[s[start]] ‚Üê FALSE",
        "start ‚Üê start + 1",
        "END WHILE",
        "visited[s[end]] ‚Üê TRUE",
        "max_length ‚Üê MAX(max_length, end - start + 1)",
        "END FOR",
        "OUTPUT max_length",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "start ‚Üê 0",
        "max_length ‚Üê 0",
        "CREATE empty map last_index",
        "FOR i ‚Üê 0 TO length(s) - 1 DO",
        "IF s[i] EXISTS IN last_index AND last_index[s[i]] ‚â• start THEN",
        "start ‚Üê last_index[s[i]] + 1",
        "END IF",
        "last_index[s[i]] ‚Üê i",
        "max_length ‚Üê MAX(max_length, i - start + 1)",
        "END FOR",
        "OUTPUT max_length",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "start ‚Üê 0",
        "max_length ‚Üê 0",
        "CREATE empty set seen_chars",
        "end ‚Üê 0",
        "WHILE end < length(s) DO",
        "IF s[end] NOT IN seen_chars THEN",
        "ADD s[end] TO seen_chars",
        "end ‚Üê end + 1",
        "max_length ‚Üê MAX(max_length, end - start)",
        "ELSE",
        "REMOVE s[start] FROM seen_chars",
        "start ‚Üê start + 1",
        "END IF",
        "END WHILE",
        "OUTPUT max_length",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s",
        "start ‚Üê 0",
        "max_length ‚Üê 0",
        "CREATE empty set seen_chars",
        "FOR end ‚Üê 0 TO length(s) - 1 DO",
        "current ‚Üê s[end]",
        "WHILE current IN seen_chars DO",
        "REMOVE s[start] FROM seen_chars",
        "start ‚Üê start + 1",
        "END WHILE",
        "ADD current TO seen_chars",
        "IF (end - start + 1) > max_length THEN",
        "max_length ‚Üê end - start + 1",
        "END IF",
        "END FOR",
        "OUTPUT max_length",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "3Sum",
    description: "3Sum ‚Äî Find all unique triplets that sum to zero.",
    answers: [
      [
        "BEGIN",
        "INPUT nums",
        "SORT nums",
        "CREATE empty list results",
        "FOR i ‚Üê 0 TO length(nums) - 3 DO",
        "FOR j ‚Üê i + 1 TO length(nums) - 2 DO",
        "FOR k ‚Üê j + 1 TO length(nums) - 1 DO",
        "IF nums[i] + nums[j] + nums[k] = 0 THEN",
        "IF [nums[i], nums[j], nums[k]] NOT IN results THEN",
        "ADD [nums[i], nums[j], nums[k]] TO results",
        "END IF",
        "END IF",
        "END FOR",
        "END FOR",
        "END FOR",
        "OUTPUT results",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "SORT nums",
        "CREATE empty list results",
        "FOR i ‚Üê 0 TO length(nums) - 3 DO",
        "IF i > 0 AND nums[i] = nums[i - 1] THEN",
        "CONTINUE",
        "END IF",
        "target ‚Üê -nums[i]",
        "left ‚Üê i + 1",
        "right ‚Üê length(nums) - 1",
        "WHILE left < right DO",
        "sum ‚Üê nums[left] + nums[right]",
        "IF sum = target THEN",
        "ADD [nums[i], nums[left], nums[right]] TO results",
        "left ‚Üê left + 1",
        "right ‚Üê right - 1",
        "ELSE IF sum < target THEN",
        "left ‚Üê left + 1",
        "ELSE",
        "right ‚Üê right - 1",
        "END IF",
        "END WHILE",
        "END FOR",
        "OUTPUT results",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "SORT nums in non-decreasing order",
        "CREATE empty list results",
        "FOR i ‚Üê 0 TO length(nums) - 3 DO",
        "IF i > 0 AND nums[i] = nums[i - 1] THEN",
        "CONTINUE",
        "END IF",
        "left ‚Üê i + 1",
        "right ‚Üê length(nums) - 1",
        "WHILE left < right DO",
        "sum ‚Üê nums[i] + nums[left] + nums[right]",
        "IF sum = 0 THEN",
        "ADD [nums[i], nums[left], nums[right]] TO results",
        "left ‚Üê left + 1",
        "WHILE left < right AND nums[left] = nums[left - 1] DO",
        "left ‚Üê left + 1",
        "END WHILE",
        "right ‚Üê right - 1",
        "WHILE left < right AND nums[right] = nums[right + 1] DO",
        "right ‚Üê right - 1",
        "END WHILE",
        "ELSE IF sum < 0 THEN",
        "left ‚Üê left + 1",
        "ELSE",
        "right ‚Üê right - 1",
        "END IF",
        "END WHILE",
        "END FOR",
        "OUTPUT results",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "SORT nums",
        "CREATE empty list results",
        "FOR i ‚Üê 0 TO length(nums) - 3 DO",
        "IF nums[i] > 0 THEN",
        "BREAK",
        "END IF",
        "IF i > 0 AND nums[i] = nums[i - 1] THEN",
        "CONTINUE",
        "END IF",
        "left ‚Üê i + 1",
        "right ‚Üê length(nums) - 1",
        "WHILE left < right DO",
        "sum ‚Üê nums[i] + nums[left] + nums[right]",
        "IF sum = 0 THEN",
        "ADD [nums[i], nums[left], nums[right]] TO results",
        "left ‚Üê left + 1",
        "right ‚Üê right - 1",
        "ELSE IF sum < 0 THEN",
        "left ‚Üê left + 1",
        "ELSE",
        "right ‚Üê right - 1",
        "END IF",
        "END WHILE",
        "END FOR",
        "OUTPUT results",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "SORT nums",
        "CREATE empty list results",
        "FOR i ‚Üê 0 TO length(nums) - 3 DO",
        "CREATE empty set seen",
        "FOR j ‚Üê i + 1 TO length(nums) - 1 DO",
        "third ‚Üê - (nums[i] + nums[j])",
        "IF third IN seen THEN",
        "ADD [nums[i], third, nums[j]] TO results",
        "END IF",
        "ADD nums[j] TO seen",
        "END FOR",
        "END FOR",
        "REMOVE duplicate triplets from results",
        "OUTPUT results",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Add Two Numbers",
    description:
      "Add Two Numbers ‚Äî Add two numbers represented by linked lists (digits reversed).",
    answers: [
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE empty result_list",
        "carry ‚Üê 0",
        "WHILE list1 is not empty OR list2 is not empty DO",
        "x ‚Üê value of list1 OR 0",
        "y ‚Üê value of list2 OR 0",
        "sum ‚Üê x + y + carry",
        "carry ‚Üê sum DIV 10",
        "digit ‚Üê sum MOD 10",
        "ADD digit TO result_list",
        "MOVE list1 to next node IF not empty",
        "MOVE list2 to next node IF not empty",
        "END WHILE",
        "IF carry > 0 THEN",
        "ADD carry TO result_list",
        "END IF",
        "OUTPUT result_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE dummy_node",
        "current ‚Üê dummy_node",
        "carry ‚Üê 0",
        "WHILE list1 is not empty OR list2 is not empty OR carry ‚â† 0 DO",
        "x ‚Üê value of list1 OR 0",
        "y ‚Üê value of list2 OR 0",
        "sum ‚Üê x + y + carry",
        "carry ‚Üê sum DIV 10",
        "current.next ‚Üê new node with value (sum MOD 10)",
        "MOVE current to next node",
        "MOVE list1 to next node IF not empty",
        "MOVE list2 to next node IF not empty",
        "END WHILE",
        "OUTPUT dummy_node.next",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE empty result_list",
        "carry ‚Üê 0",
        "WHILE list1 is not empty OR list2 is not empty DO",
        "IF list1 is not empty THEN",
        "x ‚Üê list1.value",
        "MOVE list1 to next node",
        "ELSE",
        "x ‚Üê 0",
        "END IF",
        "IF list2 is not empty THEN",
        "y ‚Üê list2.value",
        "MOVE list2 to next node",
        "ELSE",
        "y ‚Üê 0",
        "END IF",
        "total ‚Üê x + y + carry",
        "ADD (total MOD 10) TO result_list",
        "carry ‚Üê total DIV 10",
        "END WHILE",
        "IF carry ‚â† 0 THEN",
        "ADD carry TO result_list",
        "END IF",
        "OUTPUT result_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "CREATE empty result_list",
        "carry ‚Üê 0",
        "WHILE list1 is not empty OR list2 is not empty DO",
        "x ‚Üê 0",
        "y ‚Üê 0",
        "IF list1 is not empty THEN",
        "x ‚Üê list1.value",
        "MOVE list1 to next node",
        "END IF",
        "IF list2 is not empty THEN",
        "y ‚Üê list2.value",
        "MOVE list2 to next node",
        "END IF",
        "sum ‚Üê x + y + carry",
        "carry ‚Üê sum DIV 10",
        "ADD (sum MOD 10) TO result_list",
        "END WHILE",
        "IF carry = 1 THEN",
        "ADD 1 TO result_list",
        "END IF",
        "OUTPUT result_list",
        "END",
      ],
      [
        "BEGIN",
        "INPUT list1, list2",
        "carry ‚Üê 0",
        "result_list ‚Üê ADD_NODES(list1, list2, carry)",
        "OUTPUT result_list",
        "END",
        "FUNCTION ADD_NODES(l1, l2, carry)",
        "IF l1 is empty AND l2 is empty AND carry = 0 THEN",
        "RETURN empty",
        "END IF",
        "x ‚Üê value of l1 OR 0",
        "y ‚Üê value of l2 OR 0",
        "sum ‚Üê x + y + carry",
        "carry ‚Üê sum DIV 10",
        "node ‚Üê new node with value (sum MOD 10)",
        "node.next ‚Üê ADD_NODES(next of l1, next of l2, carry)",
        "RETURN node",
        "END FUNCTION",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Product of Array Except Self",
    description:
      "Product of Array Except Self ‚Äî Return array of products of all elements except self without using division.",
    answers: [
      [
        "BEGIN",
        "INPUT nums",
        "n ‚Üê length(nums)",
        "CREATE array prefix of size n",
        "CREATE array suffix of size n",
        "CREATE array result of size n",
        "prefix[0] ‚Üê 1",
        "FOR i ‚Üê 1 TO n - 1 DO",
        "prefix[i] ‚Üê prefix[i - 1] * nums[i - 1]",
        "END FOR",
        "suffix[n - 1] ‚Üê 1",
        "FOR i ‚Üê n - 2 DOWNTO 0 DO",
        "suffix[i] ‚Üê suffix[i + 1] * nums[i + 1]",
        "END FOR",
        "FOR i ‚Üê 0 TO n - 1 DO",
        "result[i] ‚Üê prefix[i] * suffix[i]",
        "END FOR",
        "OUTPUT result",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "n ‚Üê length(nums)",
        "CREATE array result of size n",
        "result[0] ‚Üê 1",
        "FOR i ‚Üê 1 TO n - 1 DO",
        "result[i] ‚Üê result[i - 1] * nums[i - 1]",
        "END FOR",
        "suffix ‚Üê 1",
        "FOR i ‚Üê n - 1 DOWNTO 0 DO",
        "result[i] ‚Üê result[i] * suffix",
        "suffix ‚Üê suffix * nums[i]",
        "END FOR",
        "OUTPUT result",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "n ‚Üê length(nums)",
        "CREATE array result of size n",
        "left_product ‚Üê 1",
        "FOR i ‚Üê 0 TO n - 1 DO",
        "result[i] ‚Üê left_product",
        "left_product ‚Üê left_product * nums[i]",
        "END FOR",
        "right_product ‚Üê 1",
        "FOR i ‚Üê n - 1 DOWNTO 0 DO",
        "result[i] ‚Üê result[i] * right_product",
        "right_product ‚Üê right_product * nums[i]",
        "END FOR",
        "OUTPUT result",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "n ‚Üê length(nums)",
        "CREATE array result of size n",
        "FOR i ‚Üê 0 TO n - 1 DO",
        "product ‚Üê 1",
        "FOR j ‚Üê 0 TO n - 1 DO",
        "IF i ‚â† j THEN",
        "product ‚Üê product * nums[j]",
        "END IF",
        "END FOR",
        "result[i] ‚Üê product",
        "END FOR",
        "OUTPUT result",
        "END",
      ],
      [
        "BEGIN",
        "INPUT nums",
        "n ‚Üê length(nums)",
        "CREATE array left of size n",
        "CREATE array right of size n",
        "CREATE array result of size n",
        "left[0] ‚Üê 1",
        "FOR i ‚Üê 1 TO n - 1 DO",
        "left[i] ‚Üê left[i - 1] * nums[i - 1]",
        "END FOR",
        "right[n - 1] ‚Üê 1",
        "FOR i ‚Üê n - 2 DOWNTO 0 DO",
        "right[i] ‚Üê right[i + 1] * nums[i + 1]",
        "END FOR",
        "FOR i ‚Üê 0 TO n - 1 DO",
        "result[i] ‚Üê left[i] * right[i]",
        "END FOR",
        "OUTPUT result",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Word Break II",
    description:
      "Word Break II ‚Äî Return all possible sentences by segmenting string into valid dictionary words.",
    answers: [
      [
        "BEGIN",
        "INPUT s, wordDict",
        "CREATE memo map",
        "FUNCTION dfs(start)",
        "IF start = length(s) THEN",
        "RETURN list containing empty string",
        "END IF",
        "IF start IN memo THEN",
        "RETURN memo[start]",
        "END IF",
        "CREATE empty list results",
        "FOR end ‚Üê start + 1 TO length(s) DO",
        "word ‚Üê substring(s, start, end)",
        "IF word IN wordDict THEN",
        "sub_sentences ‚Üê dfs(end)",
        "FOR each subs IN sub_sentences DO",
        'IF subs = "" THEN',
        "sentence ‚Üê word",
        "ELSE",
        'sentence ‚Üê word + " " + subs',
        "END IF",
        "ADD sentence TO results",
        "END FOR",
        "END IF",
        "END FOR",
        "memo[start] ‚Üê results",
        "RETURN results",
        "END FUNCTION",
        "OUTPUT dfs(0)",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s, wordDict",
        "CREATE memo array of size length(s)",
        "FUNCTION helper(index)",
        "IF index = length(s) THEN",
        'RETURN list containing ""',
        "END IF",
        "IF memo[index] exists THEN",
        "RETURN memo[index]",
        "END IF",
        "CREATE empty list result",
        "FOR i ‚Üê index + 1 TO length(s) DO",
        "word ‚Üê substring(s, index, i)",
        "IF word IN wordDict THEN",
        "next_list ‚Üê helper(i)",
        "FOR each sentence IN next_list DO",
        'IF sentence = "" THEN',
        "ADD word TO result",
        "ELSE",
        'ADD word + " " + sentence TO result',
        "END IF",
        "END FOR",
        "END IF",
        "END FOR",
        "memo[index] ‚Üê result",
        "RETURN result",
        "END FUNCTION",
        "OUTPUT helper(0)",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s, wordDict",
        "CREATE memo map",
        "FUNCTION buildSentences(pos)",
        "IF pos = length(s) THEN",
        "RETURN list containing empty string",
        "END IF",
        "IF memo contains pos THEN",
        "RETURN memo[pos]",
        "END IF",
        "CREATE empty list sentences",
        "FOR each word IN wordDict DO",
        "IF s starts with word at pos THEN",
        "tails ‚Üê buildSentences(pos + length(word))",
        "FOR each tail IN tails DO",
        'IF tail = "" THEN',
        "ADD word TO sentences",
        "ELSE",
        'ADD word + " " + tail TO sentences',
        "END IF",
        "END FOR",
        "END IF",
        "END FOR",
        "memo[pos] ‚Üê sentences",
        "RETURN sentences",
        "END FUNCTION",
        "OUTPUT buildSentences(0)",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s, wordDict",
        "n ‚Üê length(s)",
        "CREATE array dp of size n + 1 initialized to FALSE",
        "dp[0] ‚Üê TRUE",
        "FOR i ‚Üê 1 TO n DO",
        "FOR j ‚Üê 0 TO i DO",
        "IF dp[j] = TRUE AND substring(s, j, i) IN wordDict THEN",
        "dp[i] ‚Üê TRUE",
        "END IF",
        "END FOR",
        "END FOR",
        "CREATE empty list results",
        "FUNCTION backtrack(end, path)",
        "IF end = 0 THEN",
        "ADD reverse(path) TO results",
        "RETURN",
        "END IF",
        "FOR i ‚Üê 0 TO end - 1 DO",
        "IF dp[i] = TRUE AND substring(s, i, end) IN wordDict THEN",
        "ADD substring(s, i, end) TO path",
        "backtrack(i, path)",
        "REMOVE last element from path",
        "END IF",
        "END FOR",
        "END FUNCTION",
        "backtrack(n, empty list)",
        "OUTPUT results",
        "END",
      ],
      [
        "BEGIN",
        "INPUT s, wordDict",
        "CREATE empty list results",
        "FUNCTION dfs(index, current_sentence)",
        "IF index = length(s) THEN",
        "ADD current_sentence TO results",
        "RETURN",
        "END IF",
        "FOR i ‚Üê index + 1 TO length(s) DO",
        "word ‚Üê substring(s, index, i)",
        "IF word IN wordDict THEN",
        'IF current_sentence = "" THEN',
        "dfs(i, word)",
        "ELSE",
        'dfs(i, current_sentence + " " + word)',
        "END IF",
        "END IF",
        "END FOR",
        "END FUNCTION",
        'dfs(0, "")',
        "OUTPUT results",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Count digits in a number",
    description: "Write pseudocode to count the number of digits in a number",
    answers: [
      [
        "START",
        "READ n",
        "SET count = 0",
        "WHILE n > 0",
        "SET count = count + 1",
        "SET n = n / 10",
        "PRINT count",
        "END",
      ],
      [
        "START",
        "INPUT num",
        "SET digits = 0",
        "WHILE num != 0",
        "SET digits = digits + 1",
        "SET num = num DIV 10",
        "OUTPUT digits",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Fibonacci series up to N terms",
    description: "Write pseudocode to print the Fibonacci series up to N terms",
    answers: [
      [
        "START",
        "READ n",
        "SET a = 0",
        "SET b = 1",
        "PRINT a, b",
        "FOR i FROM 3 TO n",
        "SET c = a + b",
        "PRINT c",
        "SET a = b",
        "SET b = c",
        "END",
      ],
      [
        "START",
        "INPUT n",
        "SET first = 0",
        "SET second = 1",
        "OUTPUT first, second",
        "FOR i FROM 1 TO n-2",
        "SET next = first + second",
        "OUTPUT next",
        "SET first = second",
        "SET second = next",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Find power of a number",
    description: "Write pseudocode to calculate base raised to power exponent",
    answers: [
      [
        "START",
        "READ base, exponent",
        "SET result = 1",
        "FOR i FROM 1 TO exponent",
        "SET result = result * base",
        "PRINT result",
        "END",
      ],
      [
        "START",
        "INPUT b, e",
        "SET power = 1",
        "WHILE e > 0",
        "SET power = power * b",
        "SET e = e - 1",
        "OUTPUT power",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Check Armstrong number",
    description:
      "Write pseudocode to check if a 3-digit number is an Armstrong number",
    answers: [
      [
        "START",
        "READ n",
        "SET original = n",
        "SET sum = 0",
        "WHILE n > 0",
        "SET digit = n % 10",
        "SET sum = sum + (digit * digit * digit)",
        "SET n = n / 10",
        "IF original == sum THEN",
        "PRINT Armstrong",
        "ELSE",
        "PRINT Not Armstrong",
        "END",
      ],
      [
        "START",
        "INPUT num",
        "SET temp = num",
        "SET total = 0",
        "WHILE temp != 0",
        "SET d = temp MOD 10",
        "SET total = total + d * d * d",
        "SET temp = temp DIV 10",
        "IF num == total THEN",
        "OUTPUT Yes",
        "ELSE",
        "OUTPUT No",
        "END",
      ],
    ],
  },
  {
    difficulty: "medium",
    title: "Find LCM of two numbers",
    description:
      "Write pseudocode to find the least common multiple of two numbers",
    answers: [
      [
        "START",
        "READ a, b",
        "SET max = a",
        "IF b > a THEN",
        "SET max = b",
        "SET lcm = max",
        "WHILE true",
        "IF lcm % a == 0 AND lcm % b == 0 THEN",
        "PRINT lcm",
        "STOP",
        "SET lcm = lcm + max",
        "END",
      ],
      [
        "START",
        "INPUT num1, num2",
        "SET larger = num1",
        "IF num2 > num1 THEN",
        "SET larger = num2",
        "SET multiple = larger",
        "WHILE multiple % num1 != 0 OR multiple % num2 != 0",
        "SET multiple = multiple + larger",
        "OUTPUT multiple",
        "END",
      ],
    ],
  },

  // HARD QUESTIONS (10)
  {
    difficulty: "hard",
    title: "Binary search algorithm",
    description: "Write pseudocode for binary search on a sorted array",
    answers: [
      [
        "START",
        "READ array, target",
        "SET left = 0",
        "SET right = length(array) - 1",
        "WHILE left <= right",
        "SET mid = (left + right) / 2",
        "IF array[mid] == target THEN",
        "PRINT mid",
        "STOP",
        "IF array[mid] < target THEN",
        "SET left = mid + 1",
        "ELSE",
        "SET right = mid - 1",
        "PRINT Not Found",
        "END",
      ],
      [
        "START",
        "INPUT arr, key",
        "SET low = 0",
        "SET high = size(arr) - 1",
        "WHILE low <= high",
        "SET middle = low + (high - low) / 2",
        "IF arr[middle] == key THEN",
        "RETURN middle",
        "IF arr[middle] > key THEN",
        "SET high = middle - 1",
        "ELSE",
        "SET low = middle + 1",
        "RETURN -1",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Bubble sort algorithm",
    description: "Write pseudocode to implement bubble sort",
    answers: [
      [
        "START",
        "READ array",
        "SET n = length(array)",
        "FOR i FROM 0 TO n-1",
        "FOR j FROM 0 TO n-i-1",
        "IF array[j] > array[j+1] THEN",
        "SWAP array[j] and array[j+1]",
        "PRINT array",
        "END",
      ],
      [
        "START",
        "INPUT arr",
        "SET size = length(arr)",
        "FOR i FROM 0 TO size-2",
        "SET swapped = false",
        "FOR j FROM 0 TO size-i-2",
        "IF arr[j] > arr[j+1] THEN",
        "SWAP arr[j], arr[j+1]",
        "SET swapped = true",
        "IF swapped == false THEN",
        "BREAK",
        "OUTPUT arr",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Find GCD using Euclidean algorithm",
    description:
      "Write pseudocode to find the greatest common divisor of two numbers",
    answers: [
      [
        "START",
        "READ a, b",
        "WHILE b != 0",
        "SET temp = b",
        "SET b = a % b",
        "SET a = temp",
        "PRINT a",
        "END",
      ],
      [
        "START",
        "INPUT num1, num2",
        "WHILE num2 != 0",
        "SET remainder = num1 MOD num2",
        "SET num1 = num2",
        "SET num2 = remainder",
        "OUTPUT num1",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Selection sort algorithm",
    description: "Write pseudocode to implement selection sort",
    answers: [
      [
        "START",
        "READ array",
        "SET n = length(array)",
        "FOR i FROM 0 TO n-2",
        "SET minIndex = i",
        "FOR j FROM i+1 TO n-1",
        "IF array[j] < array[minIndex] THEN",
        "SET minIndex = j",
        "SWAP array[i] and array[minIndex]",
        "PRINT array",
        "END",
      ],
      [
        "START",
        "INPUT arr",
        "SET size = length(arr)",
        "FOR i FROM 0 TO size-2",
        "SET min = i",
        "FOR j FROM i+1 TO size-1",
        "IF arr[j] < arr[min] THEN",
        "SET min = j",
        "IF min != i THEN",
        "SWAP arr[i], arr[min]",
        "OUTPUT arr",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Insertion sort algorithm",
    description: "Write pseudocode to implement insertion sort",
    answers: [
      [
        "START",
        "READ array",
        "SET n = length(array)",
        "FOR i FROM 1 TO n-1",
        "SET key = array[i]",
        "SET j = i - 1",
        "WHILE j >= 0 AND array[j] > key",
        "SET array[j+1] = array[j]",
        "SET j = j - 1",
        "SET array[j+1] = key",
        "PRINT array",
        "END",
      ],
      [
        "START",
        "INPUT arr",
        "FOR i FROM 1 TO length(arr)-1",
        "SET current = arr[i]",
        "SET pos = i - 1",
        "WHILE pos >= 0 AND arr[pos] > current",
        "SET arr[pos+1] = arr[pos]",
        "SET pos = pos - 1",
        "SET arr[pos+1] = current",
        "OUTPUT arr",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Linear search in array",
    description:
      "Write pseudocode to search for an element in an array using linear search",
    answers: [
      [
        "START",
        "READ array, target",
        "SET n = length(array)",
        "FOR i FROM 0 TO n-1",
        "IF array[i] == target THEN",
        "PRINT i",
        "STOP",
        "PRINT Not Found",
        "END",
      ],
      [
        "START",
        "INPUT arr, key",
        "FOR index FROM 0 TO size(arr)-1",
        "IF arr[index] = key THEN",
        "OUTPUT index",
        "STOP",
        "OUTPUT -1",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Find largest element in array",
    description: "Write pseudocode to find the largest element in an array",
    answers: [
      [
        "START",
        "READ array",
        "SET max = array[0]",
        "FOR i FROM 1 TO length(array)-1",
        "IF array[i] > max THEN",
        "SET max = array[i]",
        "PRINT max",
        "END",
      ],
      [
        "START",
        "INPUT arr",
        "SET largest = arr[0]",
        "FOR i FROM 1 TO size(arr)-1",
        "IF arr[i] > largest THEN",
        "SET largest = arr[i]",
        "OUTPUT largest",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Merge two sorted arrays",
    description:
      "Write pseudocode to merge two sorted arrays into one sorted array",
    answers: [
      [
        "START",
        "READ arr1, arr2",
        "SET i = 0",
        "SET j = 0",
        "SET k = 0",
        "WHILE i < length(arr1) AND j < length(arr2)",
        "IF arr1[i] < arr2[j] THEN",
        "SET result[k] = arr1[i]",
        "SET i = i + 1",
        "ELSE",
        "SET result[k] = arr2[j]",
        "SET j = j + 1",
        "SET k = k + 1",
        "WHILE i < length(arr1)",
        "SET result[k] = arr1[i]",
        "SET i = i + 1",
        "SET k = k + 1",
        "WHILE j < length(arr2)",
        "SET result[k] = arr2[j]",
        "SET j = j + 1",
        "SET k = k + 1",
        "PRINT result",
        "END",
      ],
      [
        "START",
        "INPUT a1, a2",
        "SET p1 = 0",
        "SET p2 = 0",
        "SET index = 0",
        "WHILE p1 < size(a1) AND p2 < size(a2)",
        "IF a1[p1] <= a2[p2] THEN",
        "SET merged[index] = a1[p1]",
        "SET p1 = p1 + 1",
        "ELSE",
        "SET merged[index] = a2[p2]",
        "SET p2 = p2 + 1",
        "SET index = index + 1",
        "WHILE p1 < size(a1)",
        "SET merged[index] = a1[p1]",
        "SET p1 = p1 + 1",
        "SET index = index + 1",
        "WHILE p2 < size(a2)",
        "SET merged[index] = a2[p2]",
        "SET p2 = p2 + 1",
        "SET index = index + 1",
        "OUTPUT merged",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Check if array is sorted",
    description:
      "Write pseudocode to check if an array is sorted in ascending order",
    answers: [
      [
        "START",
        "READ array",
        "SET n = length(array)",
        "FOR i FROM 0 TO n-2",
        "IF array[i] > array[i+1] THEN",
        "PRINT Not Sorted",
        "STOP",
        "PRINT Sorted",
        "END",
      ],
      [
        "START",
        "INPUT arr",
        "SET sorted = true",
        "FOR i FROM 0 TO size(arr)-2",
        "IF arr[i] > arr[i+1] THEN",
        "SET sorted = false",
        "BREAK",
        "IF sorted == true THEN",
        "OUTPUT Yes",
        "ELSE",
        "OUTPUT No",
        "END",
      ],
    ],
  },
  {
    difficulty: "hard",
    title: "Find second largest in array",
    description:
      "Write pseudocode to find the second largest element in an array",
    answers: [
      [
        "START",
        "READ array",
        "SET first = array[0]",
        "SET second = array[0]",
        "FOR i FROM 1 TO length(array)-1",
        "IF array[i] > first THEN",
        "SET second = first",
        "SET first = array[i]",
        "ELSE IF array[i] > second AND array[i] != first THEN",
        "SET second = array[i]",
        "PRINT second",
        "END",
      ],
      [
        "START",
        "INPUT arr",
        "SET max = arr[0]",
        "SET secondMax = arr[0]",
        "FOR i FROM 1 TO size(arr)-1",
        "IF arr[i] > max THEN",
        "SET secondMax = max",
        "SET max = arr[i]",
        "ELSE IF arr[i] > secondMax AND arr[i] < max THEN",
        "SET secondMax = arr[i]",
        "OUTPUT secondMax",
        "END",
      ],
    ],
  },
];
const seedDatabase = async () => {
  try {
    console.log("üå± Seeding PostgreSQL database...");

    // IMPORTANT: order matters because of foreign keys
    await prisma.answer.deleteMany();
    await prisma.question.deleteMany();

    for (const q of questions) {
      const question = await prisma.question.create({
        data: {
          difficulty: q.difficulty,
          title: q.title,
          description: q.description,
        },
      });

      for (const ans of q.answers) {
        await prisma.answer.create({
          data: {
            code: ans, // JSON pseudocode
            questionId: question.id,
          },
        });
      }
    }

    console.log("‚úÖ Seeding completed");
  } catch (error) {
    console.error("‚ùå Error seeding database:", error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
};

seedDatabase();
